<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'db' Dialect

Imperative Database Dialect

Imperative database dialect, defining abstract/non-trivial types and high-level operations which more closely resemble SQL semantics, e.g. by supporting `NULL` values.

Supported types are integers (`i32`/`i64`), floats, bools (`i1`), `Date`, `Timestamp`, `Interval`, `Decimal`, `Char` (fixed-size buffers), and `String` (variable-length buffers). Nullable types are supported using `nullable<...>`; plain `NULL` values can be represented using `nullable<none>`.

[TOC]

## Operations

### `db.add` (::lingodb::compiler::dialect::db::AddOp)

_Add int/float/decimal_


Syntax:

```
operation ::= `db.add` $left `:` type($left) `,` $right `:` type($right) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `DB_NeedsNullWrap`, `DB_SupportsInvalidValues`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | any type or nullable
| `right` | any type or nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type


### `db.and` (::lingodb::compiler::dialect::db::AndOp)

_Logical And_


Syntax:

```
operation ::= `db.and` $vals `:` type($vals) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `vals` | variadic of 1-bit signless integer or nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | 1-bit signless integer or nullable


### `db.arrow.append` (::lingodb::compiler::dialect::db::AppendArrowOp)

_Append value to arrow array_


Syntax:

```
operation ::= `db.arrow.append` $builder `,` $value `->` type($value) attr-dict
```


#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `builder` | represents an anonymous Apache Arrow builder (building a chunked array), without knowledge of the type stored by it
| `value` | any type or nullable


### `db.arrow.load` (::lingodb::compiler::dialect::db::LoadArrowOp)

_Loads value from arrow array_


Syntax:

```
operation ::= `db.arrow.load` $array `,` $offset `->` type($res) attr-dict
```


#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `array` | represents an anonymous Apache Arrow array, without knowledge of the type stored by it
| `offset` | index

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | any type or nullable


### `db.as_nullable` (::lingodb::compiler::dialect::db::AsNullableOp)

_Convert to nullable type_


Syntax:

```
operation ::= `db.as_nullable` $val `:` type($val) ( `,` $null^ )?  `->` type($res) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `val` | any type
| `null` | 1-bit signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | nullable


### `db.between` (::lingodb::compiler::dialect::db::BetweenOp)

_Whether value is between `lower` and `upper`_


Syntax:

```
operation ::= `db.between` $val `:` type ($val) `between` $lower `:` type($lower) `,` $upper `:` type($upper) `,` `lowerInclusive` `:` $lowerInclusive `,` `upperInclusive` `:` $upperInclusive attr-dict
```

Determine whether a value is in a given range. This is preferred over (and also internally derived from) two comparisons to simplify optimizations depending on information about a value range.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `DB_NeedsNullWrap`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>lowerInclusive</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr>
<tr><td><code>upperInclusive</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `val` | any type or nullable
| `lower` | any type or nullable
| `upper` | any type or nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | 1-bit signless integer or nullable


### `db.cast` (::lingodb::compiler::dialect::db::CastOp)

_Cast value to different type_


Syntax:

```
operation ::= `db.cast` $val `:` type($val) `->` type($res) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `DB_MaySupportInvalidValues`, `DB_NeedsNullWrap`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `val` | any type or nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | any type or nullable


### `db.compare` (::lingodb::compiler::dialect::db::CmpOp)

_Compare int/Decimal/String_


Syntax:

```
operation ::= `db.compare` $predicate $left `:` type($left) `,` $right `:` type($right) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `CmpOpInterface`, `ConditionallySpeculatable`, `DB_MaySupportInvalidValues`, `DB_NeedsNullWrap`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>predicate</code></td><td>::lingodb::compiler::dialect::db::DBCmpPredicateAttr</td><td><details><summary>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6</summary><ul><li><strong>eq</strong>: Enum case: eq (eq)</li><li><strong>neq</strong>: Enum case: neq (neq)</li><li><strong>lt</strong>: Enum case: lt (lt)</li><li><strong>lte</strong>: Enum case: lte (lte)</li><li><strong>gt</strong>: Enum case: gt (gt)</li><li><strong>gte</strong>: Enum case: gte (gte)</li></ul></details></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | any type or nullable
| `right` | any type or nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | 1-bit signless integer or nullable


### `db.constant` (::lingodb::compiler::dialect::db::ConstantOp)

_Create constant value_


Syntax:

```
operation ::= `db.constant` `(` $value `)` `:` type($result) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`, `ConstantLike`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>value</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type


### `db.derive_truth` (::lingodb::compiler::dialect::db::DeriveTruth)

_Get whether a value is true-ish_


Syntax:

```
operation ::= `db.derive_truth` $val `:` type($val) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `val` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | 1-bit signless integer


### `db.div` (::lingodb::compiler::dialect::db::DivOp)

_Divide int/float/decimal_


Syntax:

```
operation ::= `db.div` $left `:` type($left) `,` $right `:` type($right) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `DB_NeedsNullWrap`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | any type or nullable
| `right` | any type or nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type


### `db.hash` (::lingodb::compiler::dialect::db::Hash)

_Compute hash_


Syntax:

```
operation ::= `db.hash` $val `:` type($val) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `val` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `hash` | index


### `db.isnull` (::lingodb::compiler::dialect::db::IsNullOp)

_Indicate whether a nullable value is null_


Syntax:

```
operation ::= `db.isnull` $val `:` type($val) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `val` | nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 1-bit signless integer


### `db.mod` (::lingodb::compiler::dialect::db::ModOp)

_Remainder of int/float/decimal_


Syntax:

```
operation ::= `db.mod` $left `:` type($left) `,` $right `:` type($right) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `DB_NeedsNullWrap`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | any type or nullable
| `right` | any type or nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type


### `db.mul` (::lingodb::compiler::dialect::db::MulOp)

_Multiply int/float/decimal_


Syntax:

```
operation ::= `db.mul` $left `:` type($left) `,` $right `:` type($right) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `DB_NeedsNullWrap`, `DB_SupportsInvalidValues`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | any type or nullable
| `right` | any type or nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type


### `db.not` (::lingodb::compiler::dialect::db::NotOp)

_Logical Not_


Syntax:

```
operation ::= `db.not` $val `:` type($val) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`

Interfaces: `ConditionallySpeculatable`, `DB_NeedsNullWrap`, `DB_SupportsInvalidValues`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `val` | 1-bit signless integer or nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | 1-bit signless integer or nullable


### `db.null` (::lingodb::compiler::dialect::db::NullOp)

_Create null value_


Syntax:

```
operation ::= `db.null` `:` type($res) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | nullable


### `db.nullable_get_val` (::lingodb::compiler::dialect::db::NullableGetVal)

_Get value of nullable type_


Syntax:

```
operation ::= `db.nullable_get_val` $val `:` type($val)  attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `val` | nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | any type


### `db.oneof` (::lingodb::compiler::dialect::db::OneOfOp)

_Whether `val` is included in `vals`_


Syntax:

```
operation ::= `db.oneof` $val `:` type ($val) `?` $vals `:` type ($vals) attr-dict
```

Determine whether `val` is included in `vals`; similar to `IN` in SQL.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `DB_NeedsNullWrap`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `val` | any type or nullable
| `vals` | variadic of any type or nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | 1-bit signless integer or nullable


### `db.or` (::lingodb::compiler::dialect::db::OrOp)

_Logical Or_


Syntax:

```
operation ::= `db.or` $vals `:` type($vals) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `vals` | variadic of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | 1-bit signless integer or nullable


### `db.runtime_call` (::lingodb::compiler::dialect::db::RuntimeCall)

_Call runtime function_


Syntax:

```
operation ::= `db.runtime_call` $fn  `(` $args `)` `:`  functional-type($args,$res)  attr-dict
```


Interfaces: `DB_MayNeedNullWrap`, `DB_MaySupportInvalidValues`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>fn</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `args` | variadic of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | any type


### `db.sort_compare` (::lingodb::compiler::dialect::db::SortCompare)

_Get whether a value is true-ish_


Syntax:

```
operation ::= `db.sort_compare` $left `:` type($left) `,` $right `:` type($right) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | any type
| `right` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | 8-bit signless integer


### `db.sub` (::lingodb::compiler::dialect::db::SubOp)

_Subtract int/float/decimal_


Syntax:

```
operation ::= `db.sub` $left `:` type($left) `,` $right `:` type($right) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `DB_NeedsNullWrap`, `DB_SupportsInvalidValues`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | any type or nullable
| `right` | any type or nullable

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type


## Types

### CharType

char

Syntax:

```
!db.char<
  unsigned   # len
>
```

Fixed-size array of chars.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| len | `unsigned` |  |

### DateType

date

Syntax:

```
!db.date<
  DateUnitAttr   # unit
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| unit | `DateUnitAttr` |  |

### DecimalType

decimal

Syntax:

```
!db.decimal<
  int,   # p
  int   # s
>
```

Decimal type with `p` digits in total and `s` digits after the decimal point.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| p | `int` |  |
| s | `int` |  |

### IntervalType

interval

Syntax:

```
!db.interval<
  IntervalUnitAttr   # unit
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| unit | `IntervalUnitAttr` |  |

### StringType

string

Syntax: `!db.string`

Variable-length string.

### TimestampType

timestamp

Syntax:

```
!db.timestamp<
  TimeUnitAttr   # unit
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| unit | `TimeUnitAttr` |  |

### NullableType

nullable

Syntax:

```
!db.nullable<
  mlir::Type   # type
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `mlir::Type` |  |

## Enums

### DBCmpPredicate

allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| eq | `0` | eq |
| neq | `1` | neq |
| lt | `2` | lt |
| lte | `3` | lte |
| gt | `4` | gt |
| gte | `5` | gte |
| isa | `6` | isa |

### DateUnitAttr

allowed 64-bit signless integer cases: 0, 1

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| day | `0` | day |
| millisecond | `1` | millisecond |

### IntervalUnitAttr

allowed 64-bit signless integer cases: 0, 1

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| months | `0` | months |
| daytime | `1` | daytime |

### TimeUnitAttr

allowed 64-bit signless integer cases: 0, 1, 2, 3

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| second | `0` | second |
| millisecond | `1` | millisecond |
| microsecond | `2` | microsecond |
| nanosecond | `3` | nanosecond |

