<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'relalg' Dialect

A dialect for relational algebra


## Operations

### `relalg.aggregation` (::lingodb::compiler::dialect::relalg::AggregationOp)

_Aggregation operation_


Syntax:

```
operation ::= `relalg.aggregation` $rel custom<CustRefArr>($group_by_cols) `computes` `:` custom<CustDefArr>($computed_cols) custom<CustRegion>($aggr_func)  attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `UnaryOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>group_by_cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>computed_cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.aggrfn` (::lingodb::compiler::dialect::relalg::AggrFuncOp)

_Aggregation operation_


Syntax:

```
operation ::= `relalg.aggrfn` $fn custom<CustRef>($attr) $rel `:` type($result) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>fn</code></td><td>::lingodb::compiler::dialect::relalg::AggrFuncAttr</td><td><details><summary>aggregation function</summary><ul><li><strong>sum</strong>: Enum case: sum (sum)</li><li><strong>min</strong>: Enum case: min (min)</li><li><strong>max</strong>: Enum case: max (max)</li><li><strong>avg</strong>: Enum case: avg (avg)</li><li><strong>count</strong>: Enum case: count (count)</li><li><strong>any</strong>: Enum case: any (any)</li><li><strong>stddev_samp</strong>: Enum case: stddev_samp (stddev_samp)</li></ul></details></td></tr>
<tr><td><code>attr</code></td><td>::lingodb::compiler::dialect::tuples::ColumnRefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type


### `relalg.antisemijoin` (::lingodb::compiler::dialect::relalg::AntiSemiJoinOp)

_Antisemi join operation_


Syntax:

```
operation ::= `relalg.antisemijoin` $left `,` $right custom<CustRegion>($predicate) attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `PredicateOperator`, `TupleLamdaOperator`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.basetable` (::lingodb::compiler::dialect::relalg::BaseTableOp)

_Base table operation_


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>table_identifier</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>columns</code></td><td>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.collectionjoin` (::lingodb::compiler::dialect::relalg::CollectionJoinOp)

_Collection join operation_


Syntax:

```
operation ::= `relalg.collectionjoin` custom<CustRefArr>($cols) custom<CustDef>($collAttr) $left `,` $right custom<CustRegion>($predicate)  attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `PredicateOperator`, `TupleLamdaOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>collAttr</code></td><td>::lingodb::compiler::dialect::tuples::ColumnDefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.const_relation` (::lingodb::compiler::dialect::relalg::ConstRelationOp)

_Constant relation_


Syntax:

```
operation ::= `relalg.const_relation` `columns` `:` custom<CustDefArr>($columns) `values` `:` $values attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>columns</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>values</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.count` (::lingodb::compiler::dialect::relalg::CountRowsOp)

_Count rows_


Syntax:

```
operation ::= `relalg.count` $rel attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | 64-bit signless integer


### `relalg.crossproduct` (::lingodb::compiler::dialect::relalg::CrossProductOp)

_Crossproduct operation_


Syntax:

```
operation ::= `relalg.crossproduct` $left `,` $right attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.except` (::lingodb::compiler::dialect::relalg::ExceptOp)

_Except operation_


Syntax:

```
operation ::= `relalg.except` $set_semantic $left `,` $right custom<CustAttrMapping>($mapping) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>set_semantic</code></td><td>::lingodb::compiler::dialect::relalg::SetSemanticAttr</td><td><details><summary>allowed 64-bit signless integer cases: 0, 1</summary><ul><li><strong>distinct</strong>: Enum case: distinct (distinct)</li></ul></details></td></tr>
<tr><td><code>mapping</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.exists` (::lingodb::compiler::dialect::relalg::ExistsOp)

Syntax:

```
operation ::= `relalg.exists` $rel attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 1-bit signless integer


### `relalg.fullouterjoin` (::lingodb::compiler::dialect::relalg::FullOuterJoinOp)

_Full outer join operation_


Syntax:

```
operation ::= `relalg.fullouterjoin` $left `,` $right custom<CustRegion>($predicate)  custom<CustAttrMapping>($mapping) attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `PredicateOperator`, `TupleLamdaOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>mapping</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.getlist` (::lingodb::compiler::dialect::relalg::GetListOp)

_Get multiple columns_


Syntax:

```
operation ::= `relalg.getlist` $rel custom<CustRefArr>($cols) `:` type($res) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | DB collection type


### `relalg.getscalar` (::lingodb::compiler::dialect::relalg::GetScalarOp)

_Get column_


Syntax:

```
operation ::= `relalg.getscalar` custom<CustRef>($attr) $rel `:` type($res) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>attr</code></td><td>::lingodb::compiler::dialect::tuples::ColumnRefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | any type


### `relalg.groupjoin` (::lingodb::compiler::dialect::relalg::GroupJoinOp)

_Groupjoin operation_


Syntax:

```
operation ::= `relalg.groupjoin` $left `,` $right `behavior` `=` $behavior custom<CustRefArr>($leftCols) `=` custom<CustRefArr>($rightCols) custom<CustRegion>($predicate) `mapped` `:` custom<CustDefArr>($mapped_cols) custom<CustRegion>($map_func) `computes` `:` custom<CustDefArr>($computed_cols) custom<CustRegion>($aggr_func)  attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>behavior</code></td><td>::lingodb::compiler::dialect::relalg::GroupJoinBehaviorAttr</td><td><details><summary>groupjoin behavior</summary><ul><li><strong>inner</strong>: Enum case: inner (inner)</li></ul></details></td></tr>
<tr><td><code>leftCols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>rightCols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>mapped_cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>computed_cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.in` (::lingodb::compiler::dialect::relalg::InOp)

_In operation_


Syntax:

```
operation ::= `relalg.in` $val `:` type($val) `,` $rel attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `val` | any type
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | 1-bit signless integer


### `relalg.intersect` (::lingodb::compiler::dialect::relalg::IntersectOp)

_Intersect operation_


Syntax:

```
operation ::= `relalg.intersect` $set_semantic $left `,` $right custom<CustAttrMapping>($mapping) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>set_semantic</code></td><td>::lingodb::compiler::dialect::relalg::SetSemanticAttr</td><td><details><summary>allowed 64-bit signless integer cases: 0, 1</summary><ul><li><strong>distinct</strong>: Enum case: distinct (distinct)</li></ul></details></td></tr>
<tr><td><code>mapping</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.join` (::lingodb::compiler::dialect::relalg::InnerJoinOp)

_Inner join operation_


Syntax:

```
operation ::= `relalg.join` $left `,` $right custom<CustRegion>($predicate) attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `PredicateOperator`, `TupleLamdaOperator`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.limit` (::lingodb::compiler::dialect::relalg::LimitOp)

_Limit operation_


Syntax:

```
operation ::= `relalg.limit` $max_rows $rel attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `UnaryOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>max_rows</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.map` (::lingodb::compiler::dialect::relalg::MapOp)

_Map operation_


Syntax:

```
operation ::= `relalg.map` $rel `computes` `:` custom<CustDefArr>($computed_cols) custom<CustRegion>($predicate) attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `TupleLamdaOperator`, `UnaryOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>computed_cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.markjoin` (::lingodb::compiler::dialect::relalg::MarkJoinOp)

_Mark join operation_


Syntax:

```
operation ::= `relalg.markjoin` custom<CustDef>($markattr) $left `,` $right custom<CustRegion>($predicate)  attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `PredicateOperator`, `TupleLamdaOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>markattr</code></td><td>::lingodb::compiler::dialect::tuples::ColumnDefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.materialize` (::lingodb::compiler::dialect::relalg::MaterializeOp)

Syntax:

```
operation ::= `relalg.materialize` $rel custom<CustRefArr>($cols) `=` `>` $columns `:` type($result) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>columns</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | result table type


### `relalg.nested` (::lingodb::compiler::dialect::relalg::NestedOp)

_Nested_


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>used_cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>available_cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inputs` | variadic of tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.outerjoin` (::lingodb::compiler::dialect::relalg::OuterJoinOp)

_Outer join operation_


Syntax:

```
operation ::= `relalg.outerjoin` $left `,` $right custom<CustRegion>($predicate)  custom<CustAttrMapping>($mapping) attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `PredicateOperator`, `TupleLamdaOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>mapping</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.projection` (::lingodb::compiler::dialect::relalg::ProjectionOp)

_Projection operation_


Syntax:

```
operation ::= `relalg.projection` $set_semantic custom<CustRefArr>($cols) $rel attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `UnaryOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>set_semantic</code></td><td>::lingodb::compiler::dialect::relalg::SetSemanticAttr</td><td><details><summary>allowed 64-bit signless integer cases: 0, 1</summary><ul><li><strong>distinct</strong>: Enum case: distinct (distinct)</li></ul></details></td></tr>
<tr><td><code>cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.query` (::lingodb::compiler::dialect::relalg::QueryOp)

_Query_


Syntax:

```
operation ::= `relalg.query` ($inputs^ `:` type($inputs))? custom<CustRegion>($query_ops)  `->` type($results) attr-dict-with-keyword
```


#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inputs` | variadic of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | variadic of any type


### `relalg.query_return` (::lingodb::compiler::dialect::relalg::QueryReturnOp)

_Query return_


Syntax:

```
operation ::= `relalg.query_return` ($inputs^ `:` type($inputs))? attr-dict-with-keyword
```


Traits: `Terminator`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inputs` | variadic of any type


### `relalg.rank` (::lingodb::compiler::dialect::relalg::RankOp)

_Rank inside window_


Syntax:

```
operation ::= `relalg.rank` $rel attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | 64-bit signless integer


### `relalg.renaming` (::lingodb::compiler::dialect::relalg::RenamingOp)

_Renaming columns in relation_


Syntax:

```
operation ::= `relalg.renaming` $rel `renamed` `:` custom<CustDefArr>($columns) attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `UnaryOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>columns</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.selection` (::lingodb::compiler::dialect::relalg::SelectionOp)

_Selection operation_


Syntax:

```
operation ::= `relalg.selection` $rel custom<CustRegion>($predicate) attr-dict-with-keyword
```

Filter tuple stream, the region returns `1` iff the value should be
contained in the output stream.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `PredicateOperator`, `TupleLamdaOperator`, `UnaryOperator`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.semijoin` (::lingodb::compiler::dialect::relalg::SemiJoinOp)

_Semi join operation_


Syntax:

```
operation ::= `relalg.semijoin` $left `,` $right custom<CustRegion>($predicate) attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `PredicateOperator`, `TupleLamdaOperator`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.singlejoin` (::lingodb::compiler::dialect::relalg::SingleJoinOp)

_Single join operation_


Syntax:

```
operation ::= `relalg.singlejoin` $left `,` $right custom<CustRegion>($predicate)  custom<CustAttrMapping>($mapping) attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `PredicateOperator`, `TupleLamdaOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>mapping</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.sort` (::lingodb::compiler::dialect::relalg::SortOp)

_Sort operation_


Syntax:

```
operation ::= `relalg.sort` $rel custom<SortSpecs>($sortspecs) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `UnaryOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>sortspecs</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.tmp` (::lingodb::compiler::dialect::relalg::TmpOp)

_Temporary materialization_


Syntax:

```
operation ::= `relalg.tmp` $rel custom<CustRefArr>($cols) `->` type($resulting) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `resulting` | variadic of tuple stream type


### `relalg.topk` (::lingodb::compiler::dialect::relalg::TopKOp)

_Top k operation_


Syntax:

```
operation ::= `relalg.topk` $max_rows $rel custom<SortSpecs>($sortspecs) attr-dict
```

Return top `max_rows` elements according to the sorting region. This is
conceptually similar to a combination of `sort` and `limit`, but allows
for further optimizations.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `UnaryOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>max_rows</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>sortspecs</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.track_tuples` (::lingodb::compiler::dialect::relalg::TrackTuplesOP)

_Track tuples_


Syntax:

```
operation ::= `relalg.track_tuples` $rel $resultId attr-dict
```


Interfaces: `Operator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>resultId</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type


### `relalg.union` (::lingodb::compiler::dialect::relalg::UnionOp)

_Union operation_


Syntax:

```
operation ::= `relalg.union` $set_semantic $left `,` $right custom<CustAttrMapping>($mapping) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `BinaryOperator`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>set_semantic</code></td><td>::lingodb::compiler::dialect::relalg::SetSemanticAttr</td><td><details><summary>allowed 64-bit signless integer cases: 0, 1</summary><ul><li><strong>distinct</strong>: Enum case: distinct (distinct)</li></ul></details></td></tr>
<tr><td><code>mapping</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `left` | tuple stream type
| `right` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `relalg.window` (::lingodb::compiler::dialect::relalg::WindowOp)

_Window operation_


Syntax:

```
operation ::= `relalg.window` $rel `partitionBy` `:` custom<CustRefArr>($partition_by) `orderBy` `:` custom<SortSpecs>($order_by) `rows_between` `:` $from `and` $to `computes` `:` custom<CustDefArr>($computed_cols) custom<CustRegion>($aggr_func)  attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Operator`, `UnaryOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>partition_by</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>order_by</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>computed_cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>from</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>to</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `rel` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


## Attributes

### SortSpecificationAttr





#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| attr | `lingodb::compiler::dialect::tuples::ColumnRefAttr` |  |
| sortSpec | `SortSpec` |  |

### TableMetaDataAttr





#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| meta | `std::shared_ptr<catalog::TableMetaDataProvider>` |  |

## Enums

### AggrFunc

aggregation function

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| sum | `0` | sum |
| min | `1` | min |
| max | `2` | max |
| avg | `3` | avg |
| count | `4` | count |
| any | `5` | any |
| stddev_samp | `6` | stddev_samp |
| var_samp | `7` | var_samp |

### GroupJoinBehavior

groupjoin behavior

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| inner | `0` | inner |
| outer | `1` | outer |

### SetSemantic

allowed 64-bit signless integer cases: 0, 1

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| distinct | `0` | distinct |
| all | `1` | all |

### SortSpec

sort order

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| desc | `0` | desc |
| asc | `1` | asc |

