<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'subop' Dialect

A dialect around sub-operators that manipulate a tuplestream, but state is managed explicitly


## Operations

### `subop.combine_tuple` (::lingodb::compiler::dialect::subop::CombineTupleOp)

_Combines stream with tuple_


Syntax:

```
operation ::= `subop.combine_tuple` $stream `,` $right attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type
| `right` | tuple type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.create` (::lingodb::compiler::dialect::subop::GenericCreateOp)

_Create new state_


Syntax:

```
operation ::= `subop.create` type($res) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `StateCreator`

Effects: `MemoryEffects::Effect{}`

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | any type


### `subop.create_array` (::lingodb::compiler::dialect::subop::CreateArrayOp)

_Create new state_


Syntax:

```
operation ::= `subop.create_array` $numElements `:` type($numElements) `->` type($res) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `numElements` | simple state with multiple members

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | fixed sized array


### `subop.create_continuous_view` (::lingodb::compiler::dialect::subop::CreateContinuousView)

Syntax:

```
operation ::= `subop.create_continuous_view` $source `:` type($source)  `->` type($result) attr-dict
```


Interfaces: `SubOperator`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | continuous view type


### `subop.create_from` (::lingodb::compiler::dialect::subop::CreateFrom)

_Create new state from existing state_


Syntax:

```
operation ::= `subop.create_from` $columns $state `:` type($state) `->` type($result) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>columns</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `state` | State instance

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | State instance


### `subop.create_hash_indexed_view` (::lingodb::compiler::dialect::subop::CreateHashIndexedView)

Syntax:

```
operation ::= `subop.create_hash_indexed_view` $source `:` type($source) `hash` `(` $hash_member `)` `link` `(` $link_member `)` `->` type($result) attr-dict
```


Interfaces: `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>hash_member</code></td><td>::lingodb::compiler::dialect::subop::MemberAttr</td><td><details><summary></summary><ul><li>References a member in a state, e.g., for specifying the members to sort for etc</li></ul></details></td></tr>
<tr><td><code>link_member</code></td><td>::lingodb::compiler::dialect::subop::MemberAttr</td><td><details><summary></summary><ul><li>References a member in a state, e.g., for specifying the members to sort for etc</li></ul></details></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | growing buffer type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | sorted view type


### `subop.create_heap` (::lingodb::compiler::dialect::subop::CreateHeapOp)

_Create new heap_


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>sortBy</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | heap type


### `subop.create_segment_tree_view` (::lingodb::compiler::dialect::subop::CreateSegmentTreeView)

Interfaces: `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>relevant_members</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | continuous view type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | segment tree view type


### `subop.create_simple_state` (::lingodb::compiler::dialect::subop::CreateSimpleStateOp)

_Create new state_


Syntax:

```
operation ::= `subop.create_simple_state` type($res) (`initial` `:` $initFn^)? attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | simple state with multiple members


### `subop.create_sorted_view` (::lingodb::compiler::dialect::subop::CreateSortedViewOp)

_Sort vector_

Sort a records in a vector. The region yields the order of two arguments as in C++ `std::sort`.

Traits: `IsolatedFromAbove`

Interfaces: `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>sortBy</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `toSort` | growing buffer type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | sorted view type


### `subop.create_thread_local` (::lingodb::compiler::dialect::subop::CreateThreadLocalOp)

_Create new thread local_


Syntax:

```
operation ::= `subop.create_thread_local` type($res) (`initial` `:` $initFn^)? attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | wrapper around any State that makes it thread local


### `subop.entries_between` (::lingodb::compiler::dialect::subop::EntriesBetweenOp)

Syntax:

```
operation ::= `subop.entries_between` $stream custom<CustRef>($left_ref) custom<CustRef>($right_ref)  custom<CustDef>($between) attr-dict
```


Interfaces: `InferTypeOpInterface`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>left_ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnRefAttr</td><td></td></tr>
<tr><td><code>right_ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnRefAttr</td><td></td></tr>
<tr><td><code>between</code></td><td>::lingodb::compiler::dialect::tuples::ColumnDefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.execution_group` (::lingodb::compiler::dialect::subop::ExecutionGroupOp)

_Execution group_


Syntax:

```
operation ::= `subop.execution_group` ($inputs^ `:` type($inputs))? custom<CustRegion>($sub_ops)  (`->` type($results)^ )? attr-dict-with-keyword
```


Traits: `IsolatedFromAbove`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inputs` | variadic of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | variadic of any type


### `subop.execution_group_return` (::lingodb::compiler::dialect::subop::ExecutionGroupReturnOp)

_Execution group return_


Syntax:

```
operation ::= `subop.execution_group_return` ($inputs^ `:` type($inputs))? attr-dict-with-keyword
```


Traits: `Terminator`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inputs` | variadic of any type


### `subop.execution_step` (::lingodb::compiler::dialect::subop::ExecutionStepOp)

_Execution step_


Syntax:

```
operation ::= `subop.execution_step` ($inputs^ `:` type($inputs))? $is_thread_local custom<CustRegion>($sub_ops)  (`->` type($results)^ )? attr-dict-with-keyword
```


Traits: `IsolatedFromAbove`

Interfaces: `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>is_thread_local</code></td><td>::mlir::ArrayAttr</td><td>1-bit boolean array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inputs` | variadic of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | variadic of any type


### `subop.execution_step_return` (::lingodb::compiler::dialect::subop::ExecutionStepReturnOp)

_Execution step return_


Syntax:

```
operation ::= `subop.execution_step_return` ($inputs^ `:` type($inputs))? attr-dict-with-keyword
```


Traits: `Terminator`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inputs` | variadic of any type


### `subop.filter` (::lingodb::compiler::dialect::subop::FilterOp)

_Filter stream of tuples according to one or more boolean columns (all 1 => keep tuple, otherwise discard)_


Syntax:

```
operation ::= `subop.filter` $stream $filterSemantic custom<CustRefArr>($conditions)  attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>filterSemantic</code></td><td>::lingodb::compiler::dialect::subop::FilterSemanticAttr</td><td><details><summary>allowed 64-bit signless integer cases: 0, 1</summary><ul><li><strong>all_true</strong>: Enum case: all_true (all_true)</li></ul></details></td></tr>
<tr><td><code>conditions</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.gather` (::lingodb::compiler::dialect::subop::GatherOp)

_Gather_


Syntax:

```
operation ::= `subop.gather` $stream custom<CustRef>($ref) custom<StateColumnMapping>($mapping)  attr-dict
```


Interfaces: `InferTypeOpInterface`, `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnRefAttr</td><td></td></tr>
<tr><td><code>mapping</code></td><td>::lingodb::compiler::dialect::subop::ColumnDefMemberMappingAttr</td><td><details><summary></summary><ul><li>A mapping from members to column definitions, e.g., for scans</li></ul></details></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.generate` (::lingodb::compiler::dialect::subop::GenerateOp)

_Generate tuples using imperative code_


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>generated_columns</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type
| `streams` | variadic of tuple stream type


### `subop.generate_emit` (::lingodb::compiler::dialect::subop::GenerateEmitOp)

_Set result_


Syntax:

```
operation ::= `subop.generate_emit` ($values^ `:` type($values))?  attr-dict
```


#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `values` | variadic of any type


### `subop.get_begin_ref` (::lingodb::compiler::dialect::subop::GetBeginReferenceOp)

Syntax:

```
operation ::= `subop.get_begin_ref` $stream $state `:` type($state) custom<CustDef>($ref)   attr-dict
```


Interfaces: `InferTypeOpInterface`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnDefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type
| `state` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.get_end_ref` (::lingodb::compiler::dialect::subop::GetEndReferenceOp)

Syntax:

```
operation ::= `subop.get_end_ref` $stream $state `:` type($state) custom<CustDef>($ref)   attr-dict
```


Interfaces: `InferTypeOpInterface`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnDefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type
| `state` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.get_external` (::lingodb::compiler::dialect::subop::GetExternalOp)

_Get externally defined object_


Syntax:

```
operation ::= `subop.get_external` $descr `:` type($res) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>descr</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | any type


### `subop.in_flight` (::lingodb::compiler::dialect::subop::InFlightOp)

_Operation symbolizes 'in flight' tuple stream -> values => columns_


Syntax:

```
operation ::= `subop.in_flight` $values `:` type($values) `=` `>` custom<CustDefArr>($columns) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>columns</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `values` | variadic of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.in_flight_tuple` (::lingodb::compiler::dialect::subop::InFlightTupleOp)

_Operation symbolizes 'in flight' tuple -> values => columns_


Syntax:

```
operation ::= `subop.in_flight_tuple` $values `:` type($values) `=` `>` custom<CustDefArr>($columns) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>columns</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `values` | variadic of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple type


### `subop.insert` (::lingodb::compiler::dialect::subop::InsertOp)

_Performs a lookup in a state and annotates the result as attribute_


Interfaces: `ColumnFoldable`, `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>mapping</code></td><td>::lingodb::compiler::dialect::subop::ColumnRefMemberMappingAttr</td><td><details><summary></summary><ul><li>A mapping from column references to members, e.g., for materializing operations</li></ul></details></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type
| `state` | LookupAbleState instance


### `subop.lock` (::lingodb::compiler::dialect::subop::LockOp)

_Merge thread_local_


Syntax:

```
operation ::= `subop.lock` $stream `lock` `(` $ref `)` $nested attr-dict
```


Interfaces: `InferTypeOpInterface`, `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnRefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.lookup` (::lingodb::compiler::dialect::subop::LookupOp)

_Performs a lookup in a state and annotates the result as attribute_

Currently LookupOp returns an optional reference when the state is a map structure.
It is therefore necessary to combine it with an UnwrapOptionalRefOp

Interfaces: `InferTypeOpInterface`, `ReferenceProducer`, `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>keys</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnDefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type
| `state` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.lookup_or_insert` (::lingodb::compiler::dialect::subop::LookupOrInsertOp)

_Performs a lookup in a state and annotates the result as attribute_


Interfaces: `InferTypeOpInterface`, `ReferenceProducer`, `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>keys</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnDefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type
| `state` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.loop` (::lingodb::compiler::dialect::subop::LoopOp)

_Loop_


Interfaces: `ContainsNestedSubOps`, `SubOperator`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `args` | variadic of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | variadic of any type


### `subop.loop_continue` (::lingodb::compiler::dialect::subop::LoopContinueOp)

Syntax:

```
operation ::= `subop.loop_continue` `(` $cond_state `:` type($cond_state) `[`custom<CustMemberAttr>($cond_member) `]` `)` ($values^ `:` type($values))?  attr-dict
```


Traits: `Terminator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>cond_member</code></td><td>::lingodb::compiler::dialect::subop::MemberAttr</td><td><details><summary></summary><ul><li>References a member in a state, e.g., for specifying the members to sort for etc</li></ul></details></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `cond_state` | any type
| `values` | variadic of any type


### `subop.map` (::lingodb::compiler::dialect::subop::MapOp)

_Map operation_


Syntax:

```
operation ::= `subop.map` $stream `computes` `:` custom<CustDefArr>($computed_cols) `input` `:` custom<CustRefArr>($input_cols) custom<CustRegion>($fn) attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ColumnFoldable`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>computed_cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>input_cols</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `subop.materialize` (::lingodb::compiler::dialect::subop::MaterializeOp)

_Materialize state (sequentially)_


Syntax:

```
operation ::= `subop.materialize` $stream custom<ColumnStateMapping>($mapping) `,` $state `:` type($state)  attr-dict
```


Interfaces: `ColumnFoldable`, `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>mapping</code></td><td>::lingodb::compiler::dialect::subop::ColumnRefMemberMappingAttr</td><td><details><summary></summary><ul><li>A mapping from column references to members, e.g., for materializing operations</li></ul></details></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type
| `state` | any type


### `subop.merge` (::lingodb::compiler::dialect::subop::MergeOp)

_Merge thread_local_


Syntax:

```
operation ::= `subop.merge` $threadLocal `:` type($threadLocal) `->` type($res) (`combine` `:` $combineFn^)? (`eq` `:` $eqFn^)? attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `threadLocal` | wrapper around any State that makes it thread local

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | any type


### `subop.nested_execution_group` (::lingodb::compiler::dialect::subop::NestedExecutionGroupOp)

_Nested execution group_


Syntax:

```
operation ::= `subop.nested_execution_group` ($inputs^ `:` type($inputs))? custom<CustRegion>($sub_ops)  (`->` type($results)^ )? attr-dict-with-keyword
```


Traits: `IsolatedFromAbove`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inputs` | variadic of any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | variadic of any type


### `subop.nested_execution_group_return` (::lingodb::compiler::dialect::subop::NestedExecutionGroupReturnOp)

_Nested execution group return_


Syntax:

```
operation ::= `subop.nested_execution_group_return` ($inputs^ `:` type($inputs))? attr-dict-with-keyword
```


Traits: `Terminator`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inputs` | variadic of any type


### `subop.nested_map` (::lingodb::compiler::dialect::subop::NestedMapOp)

_Compute nested map_

#
     Example:
     ```mlir
     %stream2 = subop.nested_map %stream [@x::@a, @y::@b] (%a, %b){
        %stream3 = subop.scan %some_table ...
        %stream4 = subop.filter ... {
            ... %a
            ... %b
            tuples.return %pred
        }
        tuples.return %stream5
     }
     ```
    Semantics of the produced stream: each tuple is combined with the tuples returned by the nested_map
    If no tuple is returned -> the original tuple is ommited (-> "inner-join semantic")

Interfaces: `ContainsNestedSubOps`, `InferTypeOpInterface`, `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>parameters</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.offset_ref_by` (::lingodb::compiler::dialect::subop::OffsetReferenceBy)

Syntax:

```
operation ::= `subop.offset_ref_by` $stream custom<CustRef>($ref) custom<CustRef>($idx) custom<CustDef>($newRef) attr-dict
```


Interfaces: `InferTypeOpInterface`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnRefAttr</td><td></td></tr>
<tr><td><code>idx</code></td><td>::lingodb::compiler::dialect::tuples::ColumnRefAttr</td><td></td></tr>
<tr><td><code>newRef</code></td><td>::lingodb::compiler::dialect::tuples::ColumnDefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.reduce` (::lingodb::compiler::dialect::subop::ReduceOp)

_Reduce_

```mlir
  %5 = subop.reduce %2 %0 [@studenten::@semester] with ["ctr","sum"] ([%v1], [%curr_ctr, %curr_sum]){
    %c1 = db.constant %c1
    %updated_ctr = db.add %curr_ctr, %c1
    tuples.return %updated_ctr, %updated_sum
  } eq: (){} combine: (){} initial: (){}
```

Interfaces: `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnRefAttr</td><td></td></tr>
<tr><td><code>columns</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>members</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type


### `subop.rename` (::lingodb::compiler::dialect::subop::RenamingOp)

_Rename columns_


Syntax:

```
operation ::= `subop.rename` $stream `renamed` `:` custom<CustDefArr>($columns) attr-dict-with-keyword
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>columns</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tuple stream type


### `subop.scan` (::lingodb::compiler::dialect::subop::ScanOp)

_Scan state (sequentially)_


Syntax:

```
operation ::= `subop.scan` $state `:` type($state) custom<StateColumnMapping>($mapping) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `StateUsingSubOperator`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>mapping</code></td><td>::lingodb::compiler::dialect::subop::ColumnDefMemberMappingAttr</td><td><details><summary></summary><ul><li>A mapping from members to column definitions, e.g., for scans</li></ul></details></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `state` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.scan_list` (::lingodb::compiler::dialect::subop::ScanListOp)

_Scan state (sequentially)_


Syntax:

```
operation ::= `subop.scan_list` $list `:` type($list) custom<CustDef>($elem) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ReferenceProducer`, `StateUsingSubOperator`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>elem</code></td><td>::lingodb::compiler::dialect::tuples::ColumnDefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `list` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.scan_refs` (::lingodb::compiler::dialect::subop::ScanRefsOp)

_Scan state (sequentially) and emits references to its elements_


Syntax:

```
operation ::= `subop.scan_refs` $state `:` type($state) custom<CustDef>($ref) attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ReferenceProducer`, `StateUsingSubOperator`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnDefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `state` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.scatter` (::lingodb::compiler::dialect::subop::ScatterOp)

_Scatter_


Syntax:

```
operation ::= `subop.scatter` $stream custom<CustRef>($ref) custom<ColumnStateMapping>($mapping)  attr-dict
```


Interfaces: `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnRefAttr</td><td></td></tr>
<tr><td><code>mapping</code></td><td>::lingodb::compiler::dialect::subop::ColumnRefMemberMappingAttr</td><td><details><summary></summary><ul><li>A mapping from column references to members, e.g., for materializing operations</li></ul></details></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type


### `subop.set_result` (::lingodb::compiler::dialect::subop::SetResultOp)

_Set result_


Syntax:

```
operation ::= `subop.set_result` $result_id $state `:` type($state)  attr-dict
```


#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>result_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `state` | any type


### `subop.set_tracked_count` (::lingodb::compiler::dialect::subop::SetTrackedCountOp)

_Set tracked count_


Interfaces: `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>resultId</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>readState</code></td><td>::lingodb::compiler::dialect::subop::MemberAttr</td><td><details><summary></summary><ul><li>References a member in a state, e.g., for specifying the members to sort for etc</li></ul></details></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tupleCount` | simple state with multiple members


### `subop.simple_state_get_scalar` (::lingodb::compiler::dialect::subop::SimpleStateGetScalar)

_Get scalar value of simple state_


Syntax:

```
operation ::= `subop.simple_state_get_scalar` $member $state `:` type($state) `->` type($res) attr-dict
```


Interfaces: `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>member</code></td><td>::lingodb::compiler::dialect::subop::MemberAttr</td><td><details><summary></summary><ul><li>References a member in a state, e.g., for specifying the members to sort for etc</li></ul></details></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `state` | simple state with multiple members

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | any type


### `subop.union` (::lingodb::compiler::dialect::subop::UnionOp)

_Union of two stream_


Syntax:

```
operation ::= `subop.union` $streams attr-dict
```


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SubOperator`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `streams` | variadic of tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


### `subop.unwrap_optional_ref` (::lingodb::compiler::dialect::subop::UnwrapOptionalRefOp)

Syntax:

```
operation ::= `subop.unwrap_optional_ref` $stream custom<CustRef>($optional_ref) custom<CustDef>($ref) attr-dict
```


Interfaces: `InferTypeOpInterface`, `StateUsingSubOperator`, `SubOperator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>optional_ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnRefAttr</td><td></td></tr>
<tr><td><code>ref</code></td><td>::lingodb::compiler::dialect::tuples::ColumnDefAttr</td><td></td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `stream` | tuple stream type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | tuple stream type


## Attributes

### ColumnDefMemberMappingAttr



A mapping from members to column definitions, e.g., for scans

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| mappingList | `llvm::SmallVector<std::pair<Member, tuples::ColumnDefAttr>>` |  |

### ColumnRefMemberMappingAttr



A mapping from column references to members, e.g., for materializing operations

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| mappingList | `llvm::SmallVector<std::pair<Member, tuples::ColumnRefAttr>>` |  |

### MemberAttr



References a member in a state, e.g., for specifying the members to sort for etc

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| member | `subop::Member` |  |

### StateMembersAttr



A list of members that are part of the state

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| memberList | `llvm::SmallVector<Member>` |  |

## Types

### ArrayType

fixed sized array

Syntax:

```
!subop.array<
  StateMembersAttr   # members
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| members | `StateMembersAttr` |  |

### BufferType

growing buffer type

Syntax:

```
!subop.buffer<
  StateMembersAttr   # members
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| members | `StateMembersAttr` |  |

### ContinuousEntryRefType

reference to entry of some state

Syntax:

```
!subop.continous_entry_ref<
  State   # state
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| state | `State` |  |

### ContinuousViewType

continuous view type

Syntax:

```
!subop.continuous_view<
  State   # based_on
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| based_on | `State` |  |

### EntryType

entry of some state

Syntax:

```
!subop.entry<
  mlir::Type   # t
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| t | `mlir::Type` |  |

### ListType

list type

Syntax:

```
!subop.list<
  StateEntryReference   # t
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| t | `StateEntryReference` |  |

### ExternalHashIndexType

external hash index: key -> [values]

Syntax:

```
!subop.externalhashindex<
  StateMembersAttr,   # keyMembers
  StateMembersAttr   # valueMembers
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| keyMembers | `StateMembersAttr` |  |
| valueMembers | `StateMembersAttr` |  |

### ExternalHashIndexEntryRefType

reference to entry of some state

Syntax:

```
!subop.external_hash_index_entry_ref<
  ExternalHashIndexType   # external_hash_index
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| external_hash_index | `ExternalHashIndexType` |  |

### EntryRefType

reference to entry of some state

Syntax:

```
!subop.entry_ref<
  State   # state
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| state | `State` |  |

### LookupEntryRefType

reference to entry of some state

Syntax:

```
!subop.lookup_entry_ref<
  LookupAbleState   # state
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| state | `LookupAbleState` |  |

### HashIndexedViewType

sorted view type

Syntax:

```
!subop.hash_indexed_view<
  StateMembersAttr,   # keyMembers
  StateMembersAttr,   # valueMembers
  bool   # compareHashForLookup
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| keyMembers | `StateMembersAttr` |  |
| valueMembers | `StateMembersAttr` |  |
| compareHashForLookup | `bool` |  |

### HashMapEntryRefType

reference to entry of some state

Syntax:

```
!subop.hash_map_entry_ref<
  HashMapType   # hash_map
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| hash_map | `HashMapType` |  |

### HashMultiMapEntryRefType

reference to entry of some state

Syntax:

```
!subop.hash_multimap_entry_ref<
  HashMultiMapType   # hash_multimap
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| hash_multimap | `HashMultiMapType` |  |

### HashMultiMapType

simple state with multiple members

Syntax:

```
!subop.hashmultimap<
  StateMembersAttr,   # keyMembers
  StateMembersAttr   # valueMembers
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| keyMembers | `StateMembersAttr` |  |
| valueMembers | `StateMembersAttr` |  |

### HashMapType

simple state with multiple members

Syntax:

```
!subop.hashmap<
  StateMembersAttr,   # keyMembers
  StateMembersAttr,   # valueMembers
  bool   # withLock
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| keyMembers | `StateMembersAttr` |  |
| valueMembers | `StateMembersAttr` |  |
| withLock | `bool` |  |

### HeapType

heap type

Syntax:

```
!subop.heap<
  StateMembersAttr,   # members
  uint32_t   # max_elements
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| members | `StateMembersAttr` |  |
| max_elements | `uint32_t` |  |

### LocalTableType

local table

Syntax:

```
!subop.local_table<
  StateMembersAttr,   # members
  mlir::ArrayAttr   # columnNames
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| members | `StateMembersAttr` |  |
| columnNames | `mlir::ArrayAttr` |  |

### MapType

simple state with multiple members

Syntax:

```
!subop.map<
  StateMembersAttr,   # keyMembers
  StateMembersAttr,   # valueMembers
  bool   # withLock
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| keyMembers | `StateMembersAttr` |  |
| valueMembers | `StateMembersAttr` |  |
| withLock | `bool` |  |

### MapEntryRefType

reference to entry of some state

Syntax:

```
!subop.map_entry_ref<
  MapType   # map
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| map | `MapType` |  |

### MultiMapType

multi map: key -> [values]

Syntax:

```
!subop.multimap<
  StateMembersAttr,   # keyMembers
  StateMembersAttr   # valueMembers
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| keyMembers | `StateMembersAttr` |  |
| valueMembers | `StateMembersAttr` |  |

### MultiMapEntryRefType

reference to entry of some state

Syntax:

```
!subop.multi_map_entry_ref<
  MultiMapType   # multi_map
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| multi_map | `MultiMapType` |  |

### OptionalType

optional type

Syntax:

```
!subop.optional<
  StateEntryReference   # t
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| t | `StateEntryReference` |  |

### PreAggrHTEntryRefType

reference to entry of some state

Syntax:

```
!subop.optimistic_ht_entry_ref<
  PreAggrHtType   # hash_map
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| hash_map | `PreAggrHtType` |  |

### PreAggrHtType



Syntax:

```
!subop.optimistic_ht<
  StateMembersAttr,   # keyMembers
  StateMembersAttr,   # valueMembers
  bool   # withLock
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| keyMembers | `StateMembersAttr` |  |
| valueMembers | `StateMembersAttr` |  |
| withLock | `bool` |  |

### PreAggrHtFragmentType



Syntax:

```
!subop.optimistic_ht_fragment<
  StateMembersAttr,   # keyMembers
  StateMembersAttr,   # valueMembers
  bool   # withLock
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| keyMembers | `StateMembersAttr` |  |
| valueMembers | `StateMembersAttr` |  |
| withLock | `bool` |  |

### ResultTableType

reference to table

Syntax:

```
!subop.result_table<
  StateMembersAttr   # members
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| members | `StateMembersAttr` |  |

### SegmentTreeViewType

segment tree view type

Syntax:

```
!subop.segment_tree_view<
  StateMembersAttr,   # keyMembers
  StateMembersAttr   # valueMembers
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| keyMembers | `StateMembersAttr` |  |
| valueMembers | `StateMembersAttr` |  |

### SimpleStateType

simple state with multiple members

Syntax:

```
!subop.simple_state<
  StateMembersAttr   # members
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| members | `StateMembersAttr` |  |

### SortedViewType

sorted view type

Syntax:

```
!subop.sorted_view<
  State   # based_on
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| based_on | `State` |  |

### TableType

external table

Syntax:

```
!subop.table<
  StateMembersAttr   # members
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| members | `StateMembersAttr` |  |

### TableEntryRefType

reference to entry of table

Syntax:

```
!subop.table_entry_ref<
  StateMembersAttr   # tableColumns
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| tableColumns | `StateMembersAttr` |  |

### ThreadLocalType

wrapper around any State that makes it thread local

Syntax:

```
!subop.thread_local<
  State   # wrapped
>
```



#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| wrapped | `State` |  |

## Enums

### FilterSemantic

allowed 64-bit signless integer cases: 0, 1

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| all_true | `0` | all_true |
| none_true | `1` | none_true |

